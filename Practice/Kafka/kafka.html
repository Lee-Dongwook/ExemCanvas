<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kafka</title>
</head>
<body>
    <canvas id="kafkaCanvas" width="600px" height="600px"></canvas>     
    <canvas id="kafkaAnimationCanvas" width="300px" height="400px"></canvas>  
<script>
    const kafkaCanvas = document.getElementById('kafkaCanvas');
    const kafkaCanvasContext = kafkaCanvas.getContext('2d');
    
    const kafkaCanvasWidth = kafkaCanvas.width;
    const kafkaCanvasHeight = kafkaCanvas.height;

    const kafkaConfig = {
        center: {
            x: 100,
            y: 100,
        },
        outerRect: {
            width: 400,
            height: 200,
            radius: 0,
            lineWidth: 15,
            lineJoin: 'round',
            strokeStyle: '#7ab3f7'
        },
        innerRect: {
            width: 400,
            height: 200,
            radius: 10,
            fillStyle: '#000'
        },

    }

    const buildKafkaOuterRect = (config) => {
        
        const {center, outerRect} = config;

        kafkaCanvasContext.beginPath();
        kafkaCanvasContext.lineWidth = outerRect.lineWidth;
        kafkaCanvasContext.lineJoin = outerRect.lineJoin;
        kafkaCanvasContext.strokeStyle = outerRect.strokeStyle;
        kafkaCanvasContext.strokeRect(
            center.x + (outerRect.radius / 2), 
            center.y + (outerRect.radius / 2),
            outerRect.width - outerRect.radius,
            outerRect.height - outerRect.radius
            )
        kafkaCanvasContext.stroke();
    }

    const buildKafkaInnerRect = (config) => {

        const {center, innerRect} = config;

        kafkaCanvasContext.fillStyle = innerRect.fillStyle;
        kafkaCanvasContext.fillRect(
            center.x + (innerRect.radius / 2), 
            center.y + (innerRect.radius / 2), 
            innerRect.width - innerRect.radius, 
            innerRect.height - innerRect.radius);
    }

    /*Animation*/

    const kafkaAnimationCanvas = document.getElementById('kafkaAnimationCanvas')
    const kafkaAnimationCanvasContext = kafkaAnimationCanvas.getContext('2d');

    const kafkaAnimationCanvasWidth = kafkaAnimationCanvas.width;
    const kafkaAnimationCanvasHeight = kafkaAnimationCanvas.height;
    
    const kafkaAnimationPoint = [];
    let time = 0;

    const kafkaAnimationConfig = {
        count: 5,
        range:{
         x: 20,
         y: 80
        },
        duration:{
        min: 20,
        max: 40
        },
        thickness: 5,
        strokeColor: 'skyblue',
        level: .35,
        curved: true
    }

    kafkaAnimationCanvasContext.lineJoin = 'round';
    kafkaAnimationCanvasContext.lineWidth = kafkaAnimationConfig.thickness;
    kafkaAnimationCanvasContext.strokeStyle = kafkaAnimationConfig.strokeColor;

    const rand = (min, max) => {
        return Math.floor((Math.random() * (max - min + 1)) + min);
    }

    const ease = (time, coordinateConfig) => {
	    if (( time/= coordinateConfig.duration / 2) < 1) return coordinateConfig.change / 2 * time * time + coordinateConfig.begin;
	    return -coordinateConfig.change / 2 * (( --time ) * ( time - 2 ) - 1) + coordinateConfig.begin;
    };

    class Point {
      
      constructor(config) {
        this.anchorX = config.x;
        this.anchorY = config.y;
        this.x = config.x;
        this.y = config.y;
        this.setTarget();
      };

      setTarget() {
        this.initialX = this.x;
        this.initialY = this.y;
        this.targetX = this.anchorX + rand(0, kafkaAnimationConfig.range.x * 2) - kafkaAnimationConfig.range.x;
        this.targetY = this.anchorY + rand(0, kafkaAnimationConfig.range.y * 2) - kafkaAnimationConfig.range.y;
        this.time = 0;
        this.duration = rand(kafkaAnimationConfig.duration.min, kafkaAnimationConfig.duration.max);
      }

      update() {
        let dx = this.targetX - this.x;
        let dy = this.targetY - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy);

        if(Math.abs(distance) <= 0) {
          this.setTarget();
        } else {
          let time = this.time;

          let yCoordinateConfig = {
            begin: this.initialY,
            change: this.targetY - this.initialY,
            duration: this.duration
          };

          this.y = ease(time, yCoordinateConfig);

          let xCoordinateConfig = {
            begin: this.initialX,
            change: this.targetX - this.initialX,
            duration: this.duration
          };

          this.x = ease(time, xCoordinateConfig);

          this.time++;
        }
      }

      render() {
          kafkaAnimationCanvasContext.beginPath();
          kafkaAnimationCanvasContext.arc(this.x, this.y, 3, 0, Math.PI * 2, false);
          kafkaAnimationCanvasContext.fillStyle = '#000';
          kafkaAnimationCanvasContext.fill();
      }
    }

    const createPoint = () => {
        let i = kafkaAnimationConfig.count + 2;
        let spacing = (kafkaAnimationCanvasWidth + (kafkaAnimationConfig.range.x * 2)) / (kafkaAnimationConfig.count - 1);
        while(i--){
            kafkaAnimationPoint.push(new Point({
                x: (spacing * (i - 1)) - kafkaAnimationConfig.range.x,
                y: kafkaAnimationCanvasHeight - (kafkaAnimationCanvasHeight * kafkaAnimationConfig.level)
            }));
        }
    }
    
    const updatePoint = () => {
      kafkaAnimationPoint.forEach((point) => {
          point.update();
      });
    };

    const renderPoint = () => {
      kafkaAnimationPoint.forEach((point) => {
          point.render();
      })
    };

    const renderShape = () => {

      kafkaAnimationCanvasContext.beginPath();

      var pointCount = kafkaAnimationPoint.length;	  
      var i;
      for (i = 0; i < pointCount - 1; i++) {
        var c = (kafkaAnimationPoint[i].x + kafkaAnimationPoint[i + 1].x) / 2;
        var d = (kafkaAnimationPoint[i].y + kafkaAnimationPoint[i + 1].y) / 2;
        kafkaAnimationCanvasContext.quadraticCurveTo(kafkaAnimationPoint[i].x, kafkaAnimationPoint[i].y, c, d);
      }
      
      kafkaAnimationCanvasContext.lineTo(
        -kafkaAnimationConfig.range.x - kafkaAnimationConfig.thickness, 
        kafkaCanvasHeight + kafkaAnimationConfig.thickness
      );

      kafkaAnimationCanvasContext.lineTo(
        kafkaAnimationCanvasWidth + kafkaAnimationConfig.range.x + kafkaAnimationConfig.thickness, 
        kafkaAnimationCanvasHeight + kafkaAnimationConfig.thickness
      );

      kafkaAnimationCanvasContext.closePath();
      kafkaAnimationCanvasContext.fillStyle = 'skyblue';
      kafkaAnimationCanvasContext.fill();
      kafkaAnimationCanvasContext.stroke();

    };

    const clear = () => {
      kafkaAnimationCanvasContext.clearRect(0, 0, kafkaAnimationCanvasWidth, kafkaAnimationCanvasHeight);
    };

    const loop = () => {
        requestAnimationFrame(loop, kafkaAnimationCanvas);
        time++;
        clear();
        createPoint();
        updatePoint();
        renderShape();
    }
   
    const kafka = (config) => {
        buildKafkaOuterRect(config);
        buildKafkaInnerRect(config);
        loop();
    }

    kafka(kafkaConfig);
</script>
</body>
</html>