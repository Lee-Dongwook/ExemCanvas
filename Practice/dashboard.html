<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DashBoard</title>
</head>
<body>
<canvas id="dashboardCanvas" width="1000px", height="1000px"></canvas>
<script>
    
    /* 초기 설정 */
    const dashboardCanvas = document.getElementById('dashboardCanvas');
    const dashboardCanvasContext = dashboardCanvas.getContext('2d');
    
    const dashboardCanvasWidth = dashboardCanvas.width; 
    const dashboardCanvasHeight = dashboardCanvas.height;

    /* Gradient */

    const dashboardGradientConfig = {
        dashboardCanvasContext: dashboardCanvasContext,
        dashboardCanvasWidth: dashboardCanvasWidth,
        dashboardCanvasHeight: dashboardCanvasHeight,
        count: 2,
        radiusStart: 30,
        radiusInc: 30,
        sizes: [],
        gradients: [],
        colors: [
            ['#196df3', '#25273d'],
            ['#594ed7', '#7b61ff'] 
        ]
    }

    /* 그라데이션 적용할 크기 설정 */
    const buildGradientSizes = (config) => {
        const {count, radiusStart, radiusInc, sizes} = config;

        for(let i = 0; i < count; i++)
        {
            let radius = radiusStart + radiusInc * (count - i - 1);
            sizes.push(radius);
        }

        return sizes
    }

    /* 그라데이션 적용할 색상 설정 */
    const buildGradientColors = (config) => {
        const { dashboardCanvasContext, dashboardCanvasWidth, dashboardCanvasHeight, count, sizes, colors, gradients } = config
        for(let i = 0 ; i < count; i++)
        {
            let radius = sizes[i];
            let gradient;

            if(i < count - 1) {
                gradient = dashboardCanvasContext.createLinearGradient(
                    dashboardCanvasWidth / 2 - radius,
                    dashboardCanvasHeight / 2 - radius,
                    dashboardCanvasWidth / 2 + radius,
                    dashboardCanvasHeight / 2 + radius
                )
            } else {
                 gradient = dashboardCanvasContext.createLinearGradient(
                    dashboardCanvasWidth / 2 + radius,
                    dashboardCanvasHeight / 2 - radius,
                    dashboardCanvasWidth / 2 - radius,
                    dashboardCanvasHeight / 2 + radius
                )
            }
    
            gradient.addColorStop(0, colors[i][0]);
            gradient.addColorStop(1, colors[i][1]);
            gradients.push(gradient);
        }

        return gradients;
    }

    /* 그라데이션 적용 */
    const buildGradient = (config, baseColor = '#fff') => {
        const {dashboardCanvasContext, dashboardCanvasWidth, dashboardCanvasHeight, count , gradients, radiusStart, radiusInc} = config
        
        // 초기설정
        dashboardCanvasContext.fillStyle = baseColor;
        dashboardCanvasContext.fillRect(0, 0, dashboardCanvasWidth, dashboardCanvasHeight);
    
        for(let i = 0; i < count; i++)
        {
            let radius = radiusStart + radiusInc * (count - i - 1);

            dashboardCanvasContext.beginPath();
            dashboardCanvasContext.arc(
                dashboardCanvasWidth / 2, 
                dashboardCanvasHeight / 2,
                radius,
                0,
                Math.PI * 2
            );
            dashboardCanvasContext.fillStyle = gradients[i];
            dashboardCanvasContext.fill();
        }
    }

    /* 완성 */
    const gradient = (config, baseColor = '#fff') => {
        const sizes = buildGradientSizes(config);
        config.sizes = sizes;

        const colors = buildGradientColors(config);
        config.gradients = colors;

        buildGradient(config, baseColor);
    }

    gradient(dashboardGradientConfig);


    /* Animation */
    const dashboardAnimationConfig  = {
    dashboardCanvas: dashboardCanvas,
    dashboardCanvasContext: dashboardCanvas.getContext('2d'),
    dashboardCanvasWidth: dashboardCanvasWidth,
    dashboardCanvasHeight: dashboardCanvasHeight,
    count: 5,
    range: {
      x: 20,
      y: 80
    },
    duration: {
      min: 20,
      max: 40
    },
    thickness: 10,
    strokeColor: '#444',
    level: .35,
    curved: true
    }

    class DashboardAnimation {
        constructor(config){
            this.anchorX = config.range.x;
            this.anchorY = config.range.y;
            this.x = config.range.x;
            this.y = config.range.y;
            this.initialX = 0;
            this.initialY = 0;
            this.targetX = 0;
            this.targetY = 0;
            this.time = 0;
            this.duration = 0;
            this.setTarget();
        }

        rand(min, max) {
            return Math.floor((Math.random() * (max - min + 1)) + min);
        }

        
        ease(time, coordinateConfig) {
            const {begin, change, duration } = coordinateConfig
        
            if (( time/= duration / 2) < 1) return change / 2 * time * time + begin;
	    
            return -change / 2 * (( --time ) * ( time - 2 ) - 1) + begin;
        }

        setTarget() {
            this.initialX = this.x;
            this.initialY = this.y;
            this.targetX = this.anchorX + this.rand(0, dashboardAnimationConfig.range.x * 2)
            this.targetY = this.anchorY + this.rand(0, dashboardAnimationConfig.range.y * 2)
            this.time = 0;
            this.duration = this.rand(
                dashboardAnimationConfig.duration.min, 
                dashboardAnimationConfig.duration.max 
            );
        }

        update() {
        let dx = this.targetX - this.x;
        let dy = this.targetY - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy);

        if(Math.abs(distance) <= 0) {
            this.setTarget();
        }
        else {
            let time = this.time;
            
            let xCoordinateConfig = {
                begin: this.initialX,
                change: this.targetX - this.initialX,
                duration: this.duration
            };

            let yCoordinateConfig = {
                begin: this.initialY,
                change: this.targetY - this.initialY,
                duration: this.duration
            };

            this.x = this.ease(time, xCoordinateConfig);
            this.y = this.ease(time, yCoordinateConfig);
            this.time++;
        }

        }

        render() {
            dashboardAnimationConfig.dashboardCanvasContext.beginPath();
            dashboardAnimationConfig.dashboardCanvasContext.arc(this.x, this.y, 3, 0, Math.PI * 2, false);
            dashboardAnimationConfig.dashboardCanvasContext.fillStyle = '#000';
            dashboardAnimationConfig.dashboardCanvasContext.fill();
        }
    }    

    const test = new DashboardAnimation(dashboardAnimationConfig);
    console.log(test);

</script>
</body>
</html>