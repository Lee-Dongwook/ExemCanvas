<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DashBoard</title>
</head>
<body>
<canvas id="dashboardCanvas" width="500px", height="500px"></canvas>
<script>
    
    /* 초기 설정 */
    const dashboardCanvas = document.getElementById('dashboardCanvas');
    const dashboardCanvasContext = dashboardCanvas.getContext('2d');
    
    const dashboardCanvasWidth = dashboardCanvas.width; 
    const dashboardCanvasHeight = dashboardCanvas.height;

    /* Gradient */

    const dashboardGradientConfig = {
        dashboardCanvasContext: dashboardCanvasContext,
        dashboardCanvasWidth: dashboardCanvasWidth,
        dashboardCanvasHeight: dashboardCanvasHeight,
        count: 2,
        radiusStart: 30,
        radiusInc: 30,
        sizes: [],
        gradients: [],
        colors: [
            ['#196df3', '#25273d'],
            ['#594ed7', '#7b61ff'] 
        ]
    }

    /* 그라데이션 적용할 크기 설정 */
    const buildGradientSizes = (config) => {
        const {count, radiusStart, radiusInc, sizes} = config;

        for(let i = 0; i < count; i++)
        {
            let radius = radiusStart + radiusInc * (count - i - 1);
            sizes.push(radius);
        }

        return sizes
    }

    /* 그라데이션 적용할 색상 설정 */
    const buildGradientColors = (config) => {
        const { dashboardCanvasContext, dashboardCanvasWidth, dashboardCanvasHeight, count, sizes, colors, gradients } = config
        for(let i = 0 ; i < count; i++)
        {
            let radius = sizes[i];
            let gradient;

            if(i < count - 1) {
                gradient = dashboardCanvasContext.createLinearGradient(
                    dashboardCanvasWidth / 2 - radius,
                    dashboardCanvasHeight / 2 - radius,
                    dashboardCanvasWidth / 2 + radius,
                    dashboardCanvasHeight / 2 + radius
                )
            } else {
                 gradient = dashboardCanvasContext.createLinearGradient(
                    dashboardCanvasWidth / 2 + radius,
                    dashboardCanvasHeight / 2 - radius,
                    dashboardCanvasWidth / 2 - radius,
                    dashboardCanvasHeight / 2 + radius
                )
            }
    
            gradient.addColorStop(0, colors[i][0]);
            gradient.addColorStop(1, colors[i][1]);
            gradients.push(gradient);
        }

        return gradients;
    }

    /* 그라데이션 적용 */
    const buildGradient = (config, baseColor = '#fff') => {
        const {dashboardCanvasContext, dashboardCanvasWidth, dashboardCanvasHeight, count , gradients, radiusStart, radiusInc} = config
        
        // 초기설정
        dashboardCanvasContext.fillStyle = baseColor;
        dashboardCanvasContext.fillRect(0, 0, dashboardCanvasWidth, dashboardCanvasHeight);
    
        for(let i = 0; i < count; i++)
        {
            let radius = radiusStart + radiusInc * (count - i - 1);

            dashboardCanvasContext.beginPath();
            dashboardCanvasContext.arc(
                dashboardCanvasWidth / 2, 
                dashboardCanvasHeight / 2,
                radius,
                0,
                Math.PI * 2
            );
            dashboardCanvasContext.fillStyle = gradients[i];
            dashboardCanvasContext.fill();
        }
    }

    /* 완성 */
    const gradient = (config, baseColor = '#fff') => {
        const sizes = buildGradientSizes(config);
        config.sizes = sizes;

        const colors = buildGradientColors(config);
        config.gradients = colors;

        buildGradient(config, baseColor);
    }

    gradient(dashboardGradientConfig);

    /* Animation */
    const dashboardAnimationConfig  = {
    count: 5,
    range: {
      x: 20,
      y: 80
    },
    duration: {
      min: 20,
      max: 40
    },
    thickness: 10,
    strokeColor: '#444',
    level: .35,
    curved: true
    }
    
    let time = 0;
    
    dashboardCanvasContext.lineJoin = 'round';
    dashboardCanvasContext.lineWidth = dashboardAnimationConfig.thickness;
    dashboardCanvasContext.strokeStyle = dashboardAnimationConfig.strokeColor;

    /* Animation Frame 저장 */
    const dashboardAnimationPoints = [];

    class DashboardAnimation {
        constructor(config){
            this.anchorX = config.x;
            this.anchorY = config.y;
            this.x = config.x;
            this.y = config.y;
            this.initialX = 0;
            this.initialY = 0;
            this.targetX = 0;
            this.targetY = 0;
            this.time = time;
            this.duration = 0;
            this.setTarget();
        }

        rand(min, max) {
            return Math.floor((Math.random() * (max - min + 1)) + min);
        }

        
        ease(time, coordinateConfig) {
            const {begin, change, duration } = coordinateConfig
        
            if (( time/= duration / 2) < 1) return change / 2 * time * time + begin;
	    
            return -change / 2 * (( --time ) * ( time - 2 ) - 1) + begin;
        }

        setTarget() {
            this.initialX = this.x;
            this.initialY = this.y;
            this.targetX = this.anchorX + this.rand(0, dashboardAnimationConfig.range.x * 2)
            this.targetY = this.anchorY + this.rand(0, dashboardAnimationConfig.range.y * 2)
            this.time = 0;
            this.duration = this.rand(
                dashboardAnimationConfig.duration.min, 
                dashboardAnimationConfig.duration.max 
            );
        }

        update() {
        let dx = this.targetX - this.x;
        let dy = this.targetY - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy);

        if(Math.abs(distance) <= 0) {
            this.setTarget();
        }
        else {
            let time = this.time;
            
            let xCoordinateConfig = {
                begin: this.initialX,
                change: this.targetX - this.initialX,
                duration: this.duration
            };

            let yCoordinateConfig = {
                begin: this.initialY,
                change: this.targetY - this.initialY,
                duration: this.duration
            };

            this.x = this.ease(time, xCoordinateConfig);
            this.y = this.ease(time, yCoordinateConfig);
            this.time++;
        }

        }

        render() {
            dashboardAnimationConfig.dashboardCanvasContext.beginPath();
            dashboardAnimationConfig.dashboardCanvasContext.arc(this.x, this.y, 3, 0, Math.PI * 2, false);
            dashboardAnimationConfig.dashboardCanvasContext.fillStyle = '#000';
            dashboardAnimationConfig.dashboardCanvasContext.fill();
        }
    } 
    
    var i = dashboardAnimationConfig.count + 2;
    var spacing = (dashboardCanvasWidth + (dashboardAnimationConfig.range.x * 2)) / (dashboardAnimationConfig.count - 1);
    while(i--){
        dashboardAnimationPoints.push(new DashboardAnimation({
            x: (spacing * (i - 1)) - dashboardAnimationConfig.range.x,
            y: dashboardCanvasHeight - (dashboardCanvasHeight * dashboardAnimationConfig.level)
        }));
    }
    

    /* Frame의 상태 업데이트 */
    const updatePoints = () => {
        dashboardAnimationPoints.forEach((point) => {
            point.update();
        })
    }


    const renderPoints = () => {
        dashboardAnimationPoints.forEach((point) => {
            point.render();
        })
    }

    const renderShape = () => {
        dashboardCanvasContext.beginPath();

        var pointCount = dashboardAnimationPoints.length;	  
        var i;
        for (i = 0; i < pointCount - 1; i++) {
            var c = (dashboardAnimationPoints[i].x + dashboardAnimationPoints[i + 1].x) / 2;
            var d = (dashboardAnimationPoints[i].y + dashboardAnimationPoints[i + 1].y) / 2;
            dashboardCanvasContext.quadraticCurveTo(dashboardAnimationPoints[i].x, dashboardAnimationPoints[i].y, c, d);
        }

        dashboardCanvasContext.lineTo(
            -dashboardAnimationConfig.range.x - dashboardAnimationConfig.thickness, 
            dashboardCanvasHeight + dashboardAnimationConfig.thickness
        );

        dashboardCanvasContext.lineTo(
            dashboardCanvasWidth + dashboardAnimationConfig.range.x + dashboardAnimationConfig.thickness, 
            dashboardCanvasHeight + dashboardAnimationConfig.thickness
        );

        dashboardCanvasContext.closePath();
        dashboardCanvasContext.fillStyle = '#000';
        dashboardCanvasContext.fill();
        dashboardCanvasContext.stroke();
    };

    const clear = () => {
      dashboardCanvasContext.clearRect(0, 0, dashboardCanvasWidth, dashboardCanvasHeight);
    };

    const animation = () => {
        requestAnimationFrame(animation, dashboardCanvas);
        time++;
        clear();
        updatePoints();
        renderShape();
        // gradient(dashboardGradientConfig);
    };

    animation();

</script>
</body>
</html>