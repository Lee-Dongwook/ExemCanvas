<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DashBoard Animation</title>
</head>
<body>
    <canvas id="dashboardCanvas"></canvas>
<script>

    const dashboardAnimationConfig = {
      count: 5,
      range: {
        x: 20,
        y: 80
      },
      duration: {
        min: 20,
        max: 40
      },
      thickness: 10,
      strokeColor: '#444',
      level: .35,
      curved: true
    };

    
    const dashboardCanvas = document.getElementById('dashboardCanvas');
    const dashboardCanvasContext = dashboardCanvas.getContext('2d');
    
    const dashboardCanvasWidth = dashboardCanvasContext.width = window.innerWidth;
    const dashboardCanvasHeight = dashboardCanvasContext.height =  window.innerHeight;

    dashboardCanvasContext.lineJoin = 'round';
    dashboardCanvasContext.lineWidth = dashboardAnimationConfig.thickness;
    dashboardCanvasContext.strokeStyle = dashboardAnimationConfig.strokeColor;
    
    let tick = 0;
    const count = dashboardAnimationConfig.count;
    const spacing = (dashboardCanvasWidth + (dashboardAnimationConfig.range.x * 2)) / (count - 1);

    const rand = (min, max) => {
        return Math.floor( (Math.random() * (max - min + 1) ) + min);
    };

    const ease = (time, base, change, duration) => {
        if((time /= duration / 2) < 1){
            return change / 2 * time * time + base;
        }

        return -change / 2 * ((--time)*(time-2) - 1) + base;
    }

    class Point {
        constructor(coordinate) {
            this.anchorX = coordinate.x;
            this.anchorY = coordinate.y;
            this.x = coordinate.x;
            this.y = coordinate.y;
            this.setTarget();
        }

        setTarget() {
            this.initialX = this.x;
            this.initialY = this.y;
            this.targetX = this.anchorX + rand(0, dashboardAnimationConfig.range.x * 2) - dashboardAnimationConfig.range.x;
            this.targetY = this.anchorY + rand(0, dashboardAnimationConfig.range.y * 2) - dashboardAnimationConfig.range.y;
            this.tick = 0;
            this.duration = rand(dashboardAnimationConfig.duration.min, dashboardAnimationConfig.duration.max);
        }

        update() {
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if(Math.abs(dist) <= 0){
                this.setTarget();
            } else {
                var t = this.tick;
                const y_b = this.initialY;
                const y_c = this.targetY - this.initialY;
                const y_d = this.duration;

                this.y = ease(t, y_b, y_c, y_d);

                const x_b = this.initialX;
                const x_c = this.targetX - this.initialX;
                const x_d = this.duration;

                this.x = ease(t, x_b, x_c, x_d);

                this.tick++;
            }
        }
        
        render() {
            dashboardCanvasContext.beginPath();
            dashboardCanvasContext.arc(this.x, this.y, 3, 0, Math.PI * 2, false);
            dashboardCanvasContext.fillStyle = '#000';
            dashboardCanvasContext.fill();
        }

        updatePoints() {
            if(this.points){
                this.points.forEach((point) => {
                    point.update();
                })
            }
        }

        renderPoints() {
            if(this.points){
                this.points.forEach((point) => {
                    point.render();
                })
            }
        }

        renderShape() {
            dashboardCanvasContext.beginPath();
            dashboardCanvasContext.moveTo(points[0].x, points[0].y);
            points.forEach((point, i, arr) => {
                if(i < arr.length - 1) {
                    var cpx = points[i].x;
                    var cpy = points[i].y;
                    var x = (points[i].x + points[i+1].x) / 2;
                    var y = (points[i].y + points[i+1].y) / 2;
                    dashboardCanvasContext.quadraticCurveTo(cpx, cpy, x, y);
                }
            })
            dashboardCanvasContext.lineTo(
                -dashboardAnimationConfig.range.x - dashboardAnimationConfig.thickness, 
                dashboardCanvasHeight + dashboardAnimationConfig.thickness
            );

            dashboardCanvasContext.lineTo(
                dashboardCanvasWidth + dashboardAnimationConfig.range.x + dashboardAnimationConfig.thickness, 
                dashboardCanvasHeight + dashboardAnimationConfig.thickness
            );

            dashboardCanvasContext.closePath();     
            dashboardCanvasContext.fillStyle = '#000';
            dashboardCanvasContext.fill();  
            dashboardCanvasContext.stroke();
        }

        clear() {
            dashboardCanvasContext.clearRect(0, 0, dashboardCanvasWidth, dashboardCanvasHeight);
        }

        loop() {    
          requestAnimationFrame(this.loop.bind(this))
          this.tick++;
          this.clear();
          this.updatePoints();
          this.renderShape();
        }
    }


    const points = Array.from({ length: count + 2 }, (_, i) => {
        return new Point({
            x: (spacing * (i - 1)) - dashboardAnimationConfig.range.x,
            y: dashboardCanvasHeight - (dashboardCanvasHeight * dashboardAnimationConfig.level)
        });
    });

    const myPoint = new Point({
        x: (spacing * (count - 1)) - dashboardAnimationConfig.range.x,
        y: dashboardCanvasHeight - (dashboardCanvasHeight * dashboardAnimationConfig.level)
    });

    myPoint.loop();
</script>
</body>
</html>
