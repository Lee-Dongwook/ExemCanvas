<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation</title>
</head>
<body>
    <canvas id="dashboardCanvas" width="300px" height="300px"></canvas>
<script>
    const dashboardCanvas = document.getElementById('dashboardCanvas');
    const dashboardCanvasContext = dashboardCanvas.getContext('2d');
    
    const dashboardCanvasWidth = dashboardCanvas.width; 
    const dashboardCanvasHeight = dashboardCanvas.height;
    
    const points = [];
    let time = 0;

    const dashboardAnimationConfig = {
      count: 5,
      range: {
        x: 20,
        y: 80
      },
      duration: {
        min: 20,
        max: 40
      },
      thickness: 10,
      strokeColor: '#444',
      level: .35,
      curved: true
    };

    dashboardCanvasContext.lineJoin = 'round';
    dashboardCanvasContext.lineWidth = dashboardAnimationConfig.thickness;
    dashboardCanvasContext.strokeStyle = dashboardAnimationConfig.strokeColor;

    const rand = (min, max) => {
        return Math.floor( (Math.random() * (max - min + 1) ) + min);
    };

    //이징함수 => 시간 흐름에 따른 매개변수의 변화율 측정 / Wave의 강도를 조절하는 부분
    const ease = (time, coordinateConfig) => {
	    if (( time/= coordinateConfig.duration / 2) < 1) return coordinateConfig.change / 2 * time * time + coordinateConfig.begin;
	    return -coordinateConfig.change / 2 * (( --time ) * ( time - 2 ) - 1) + coordinateConfig.begin;
    };

    class Point {
      
      constructor(config) {
        this.anchorX = config.x;
        this.anchorY = config.y;
        this.x = config.x;
        this.y = config.y;
        this.setTarget();
      };

      setTarget() {
        this.initialX = this.x;
        this.initialY = this.y;
        this.targetX = this.anchorX + rand(0, dashboardAnimationConfig.range.x * 2) - dashboardAnimationConfig.range.x;
        this.targetY = this.anchorY + rand(0, dashboardAnimationConfig.range.y * 2) - dashboardAnimationConfig.range.y;
        this.time = 0;
        this.duration = rand(dashboardAnimationConfig.duration.min, dashboardAnimationConfig.duration.max);
      }

      update() {
        let dx = this.targetX - this.x;
        let dy = this.targetY - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy);

        if(Math.abs(distance) <= 0) {
          this.setTarget();
        } else {
          let time = this.time;

          let yCoordinateConfig = {
            begin: this.initialY,
            change: this.targetY - this.initialY,
            duration: this.duration
          };

          this.y = ease(time, yCoordinateConfig);

          let xCoordinateConfig = {
            begin: this.initialX,
            change: this.targetX - this.initialX,
            duration: this.duration
          };

          this.x = ease(time, xCoordinateConfig);

          this.time++;
        }
      }

      render() {
          dashboardCanvasContext.beginPath();
          dashboardCanvasContext.arc(this.x, this.y, 3, 0, Math.PI * 2, false);
          dashboardCanvasContext.fillStyle = '#000';
          dashboardCanvasContext.fill();
      }
    }

    const updatePoints = () => {
      points.forEach((point) => {
          point.update();
      });
    };

    const renderPoints = () => {
      points.forEach((point) => {
          point.render();
      })
    };

    const renderShape = () => {

      dashboardCanvasContext.beginPath();

      var pointCount = points.length;	  
      var i;
      for (i = 0; i < pointCount - 1; i++) {
        var c = (points[i].x + points[i + 1].x) / 2;
        var d = (points[i].y + points[i + 1].y) / 2;
        dashboardCanvasContext.quadraticCurveTo(points[i].x, points[i].y, c, d);
      }
      dashboardCanvasContext.lineTo(
        -dashboardAnimationConfig.range.x - dashboardAnimationConfig.thickness, 
        dashboardCanvasHeight + dashboardAnimationConfig.thickness
      );

      dashboardCanvasContext.lineTo(
        dashboardCanvasWidth + dashboardAnimationConfig.range.x + dashboardAnimationConfig.thickness, 
        dashboardCanvasHeight + dashboardAnimationConfig.thickness
      );

      // points.forEach((point, index) => {

      //   let startX = points[index].x;
      //   let startY = points[index].y;
      //   let endX = (startX + points[index + 1].x) / 2;
      //   let endY = (startY + points[index + 1].y) / 2;

      //   dashboardCanvasContext.quadraticCurveTo(
      //     startX, startY, endX, endY
      //   )
      // })

      dashboardCanvasContext.closePath();
      dashboardCanvasContext.fillStyle = '#000';
      dashboardCanvasContext.fill();
      dashboardCanvasContext.stroke();

    };

    const clear = () => {
      dashboardCanvasContext.clearRect(0, 0, dashboardCanvasWidth, dashboardCanvasHeight);
    };

    var loop = function(){
        requestAnimationFrame(loop, dashboardCanvas);
        time++;
        clear();
        updatePoints();
        renderShape();
        //renderPoints();
    };

var i = dashboardAnimationConfig.count + 2;
var spacing = (dashboardCanvasWidth + (dashboardAnimationConfig.range.x * 2)) / (dashboardAnimationConfig.count - 1);
while(i--){
  points.push(new Point({
    x: (spacing * (i - 1)) - dashboardAnimationConfig.range.x,
    y: dashboardCanvasHeight - (dashboardCanvasHeight * dashboardAnimationConfig.level)
  }));
}

loop();
</script>
</body>
</html>