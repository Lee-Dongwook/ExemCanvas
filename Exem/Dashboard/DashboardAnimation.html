<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DashBoard Animation</title>
</head>
<body>
    <canvas id="dashboardCanvas" width="400px" height="400px"></canvas>
<script>
    
    const config = {
        count: 5,
        range: {
            x: 20,
            y: 80,
        },
        duration: {
            min: 20,
            max: 40,
        },
        thickness: 10,
        strokeColor: '#000',
        level: .35,
        curved: true
    };

    const dashboardCanvas = document.getElementById("dashboardCanvas");
    const dashboardCanvasContext = dashboardCanvas.getContext("2d");
    
    dashboardCanvas.linejoin = 'round';
    dashboardCanvas.lineWidth = config.thickness;
    dashboardCanvas.strokeStyle = config.strokeColor;

    const rand = (min, max) => {
        return Math.floor((Math.random() * (max - min + 1)) + min);
    }

    const ease = (t,b,c,d) => {
        if((t /= d / 2) < 1){
            return c / 2 * t * t + b;
        }
        return -c/2 * ((--t) * (t-2) - 1) + b;
    }

    class Point {
      constructor(coordinate) {
        this.anchorX = coordinate.x;
        this.anchorY = coordinate.y;
        this.x = coordinate.x;
        this.y = coordinate.y;
        this.points = [];
        this.setTarget();
      }

      setTarget() {
        this.initialX = this.x;
        this.initialY = this.y;
        this.targetX = this.anchorX + rand(0, config.range.x * 2) - config.range.x;
        this.targetY = this.anchorY + rand(0, config.range.y * 2) - config.range.y;
        this.tick = 0;
        this.duration = rand(config.duration.min, config.duration.max);
      }

      update() {
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;

        const dist = Math.sqrt(dx * dx + dy * dy);

        if(Math.abs(dist) <= 0) {
            this.setTarget();
        } else {
            const t = this.tick;
            var b = this.initialY;
            var c = this.targetY - this.initialY;
            var d = this.duration;
            this.y = ease(t, b, c, d);

            b = this.initialX;
            c = this.targetX - this.initialX;
            d = this.duration;
            this.x = ease(t, b, c, d);

            this.tick++;
        }
      }

      render() {
        dashboardCanvasContext.beginPath();
        dashboardCanvasContext.arc(this.x, this.y, 3, 0, Math.PI * 2, false);
        dashboardCanvasContext.fillStyle = '#000';
        dashboardCanvasContext.fill();
      }

      updatePoints() {
       if(this.points) {
            this.points.forEach((point) => {
                point.update()
            })
        }
      }

      renderPoints() {
        if(points) {
            points.forEach((point) => {
                point.render();
            })
        }
      }

      renderShape() {
        dashboardCanvasContext.beginPath();
        dashboardCanvasContext.moveTo(points[0].x, points[0].y);

        dashboardCanvasContext.closePath();
        dashboardCanvasContext.fillStyle = '#000';
        dashboardCanvasContext.fill();
        dashboardCanvasContext.stroke();
     }
     
     clear() {
        dashboardCanvasContext.clearRect(0,0,dashboardCanvas.width, dashboardCanvas.height)
     }

     loop() {
        this.clear();
        this.updatePoints()
        this.renderShape()

        setTimeout(() => {
            requestAnimationFrame(this.loop)
        }, 1000)
     }

    }

    const points = []
    
    var i = config.count + 2;
    const spacing = (dashboardCanvas.width + (config.range.x * 2)) / (config.count - 1);
    while(i--) {
        points.push(new Point({
            x: (spacing * ( i - 1 )) - config.range.x,
            y: dashboardCanvas.height - ( dashboardCanvas.height * config.level)
        }))    
    }

    points.forEach((point) => {
        point.loop()
    })

</script>
</body>
</html>
